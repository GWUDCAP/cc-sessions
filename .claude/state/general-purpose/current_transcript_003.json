[
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01LU1BFC94auV6kawkJgCgjb",
        "type": "tool_result",
        "content": "     1→#!/usr/bin/env node\n     2→\n     3→/**\n     4→ * Claude Code Sessions Framework - Node.js Installer\n     5→ * Cross-platform installation script for the Sessions framework\n     6→ */\n     7→\n     8→const fs = require('fs').promises;\n     9→const path = require('path');\n    10→const { execSync } = require('child_process');\n    11→const readline = require('readline');\n    12→const { promisify } = require('util');\n    13→\n    14→// Colors for terminal output\n    15→const colors = {\n    16→  reset: '\\x1b[0m',\n    17→  bright: '\\x1b[1m',\n    18→  dim: '\\x1b[2m',\n    19→  red: '\\x1b[31m',\n    20→  green: '\\x1b[32m',\n    21→  yellow: '\\x1b[33m',\n    22→  blue: '\\x1b[34m',\n    23→  magenta: '\\x1b[35m',\n    24→  cyan: '\\x1b[36m',\n    25→  white: '\\x1b[37m',\n    26→  bgRed: '\\x1b[41m',\n    27→  bgGreen: '\\x1b[42m',\n    28→  bgYellow: '\\x1b[43m',\n    29→  bgBlue: '\\x1b[44m',\n    30→  bgMagenta: '\\x1b[45m',\n    31→  bgCyan: '\\x1b[46m'\n    32→};\n    33→\n    34→// Helper to colorize output\n    35→const color = (text, colorCode) => `${colorCode}${text}${colors.reset}`;\n    36→\n    37→// Icons and symbols\n    38→const icons = {\n    39→  check: '✓',\n    40→  cross: '✗',\n    41→  lock: '🔒',\n    42→  unlock: '🔓',\n    43→  info: 'ℹ',\n    44→  warning: '⚠',\n    45→  arrow: '→',\n    46→  bullet: '•',\n    47→  star: '★'\n    48→};\n    49→\n    50→// Create readline interface\n    51→const rl = readline.createInterface({\n    52→  input: process.stdin,\n    53→  output: process.stdout\n    54→});\n    55→\n    56→const question = promisify(rl.question).bind(rl);\n    57→\n    58→// Paths\n    59→const SCRIPT_DIR = __dirname;\n    60→let PROJECT_ROOT = process.cwd();\n    61→\n    62→// Check if we're running from npx or in wrong directory\n    63→async function detectProjectDirectory() {\n    64→  // If running from node_modules or temp npx directory\n    65→  if (PROJECT_ROOT.includes('node_modules') || PROJECT_ROOT.includes('.npm')) {\n    66→    console.log(color('⚠️  Running from package directory, not project directory.', colors.yellow));\n    67→    console.log();\n    68→    const projectPath = await question('Enter the path to your project directory (or press Enter for current directory): ');\n    69→    if (projectPath) {\n    70→      PROJECT_ROOT = path.resolve(projectPath);\n    71→    } else {\n    72→      PROJECT_ROOT = process.cwd();\n    73→    }\n    74→    console.log(color(`Using project directory: ${PROJECT_ROOT}`, colors.cyan));\n    75→  }\n    76→}\n    77→\n    78→// Configuration object to build\n    79→const config = {\n    80→  developer_name: \"the developer\",\n    81→  trigger_phrases: [\"make it so\", \"run that\", \"go ahead\", \"yert\"],\n    82→  blocked_tools: [\"Edit\", \"Write\", \"MultiEdit\", \"NotebookEdit\"],\n    83→  task_detection: { enabled: true },\n    84→  branch_enforcement: { enabled: true }\n    85→};\n    86→\n    87→// Check if command exists\n    88→function commandExists(command) {\n    89→  try {\n    90→    execSync(`which ${command}`, { stdio: 'ignore' });\n    91→    return true;\n    92→  } catch {\n    93→    return false;\n    94→  }\n    95→}\n    96→\n    97→// Check dependencies\n    98→async function checkDependencies() {\n    99→  console.log(color('Checking dependencies...', colors.cyan));\n   100→  \n   101→  // Check Python\n   102→  const hasPython = commandExists('python3') || commandExists('python');\n   103→  if (!hasPython) {\n   104→    console.log(color('❌ Python 3 is required but not installed.', colors.red));\n   105→    process.exit(1);\n   106→  }\n   107→  \n   108→  // Check pip\n   109→  const hasPip = commandExists('pip3') || commandExists('pip');\n   110→  if (!hasPip) {\n   111→    console.log(color('❌ pip is required but not installed.', colors.red));\n   112→    process.exit(1);\n   113→  }\n   114→  \n   115→  // Check Git (warning only)\n   116→  if (!commandExists('git')) {\n   117→    console.log(color('⚠️  Warning: Not in a git repository. Sessions works best with git.', colors.yellow));\n   118→    const answer = await question('Continue anyway? (y/n): ');\n   119→    if (answer.toLowerCase() !== 'y') {\n   120→      process.exit(1);\n   121→    }\n   122→  }\n   123→}\n   124→\n   125→// Create directory structure\n   126→async function createDirectories() {\n   127→  console.log(color('Creating directory structure...', colors.cyan));\n   128→  \n   129→  const dirs = [\n   130→    '.claude/hooks',\n   131→    '.claude/state',\n   132→    '.claude/agents',\n   133→    '.claude/commands',\n   134→    'sessions/tasks/done',\n   135→    'sessions/protocols',\n   136→    'sessions/knowledge'\n   137→  ];\n   138→  \n   139→  for (const dir of dirs) {\n   140→    await fs.mkdir(path.join(PROJECT_ROOT, dir), { recursive: true });\n   141→  }\n   142→}\n   143→\n   144→// Install Python dependencies\n   145→async function installPythonDeps() {\n   146→  console.log(color('Installing Python dependencies...', colors.cyan));\n   147→  try {\n   148→    const pipCommand = commandExists('pip3') ? 'pip3' : 'pip';\n   149→    execSync(`${pipCommand} install tiktoken --quiet`, { stdio: 'ignore' });\n   150→  } catch (error) {\n   151→    console.log(color('⚠️  Could not install tiktoken. You may need to install it manually.', colors.yellow));\n   152→  }\n   153→}\n   154→\n   155→// Copy files with proper permissions\n   156→async function copyFiles() {\n   157→  console.log(color('Installing hooks...', colors.cyan));\n   158→  const hookFiles = await fs.readdir(path.join(SCRIPT_DIR, 'cc_sessions/hooks'));\n   159→  for (const file of hookFiles) {\n   160→    if (file.endsWith('.py')) {\n   161→      await fs.copyFile(\n   162→        path.join(SCRIPT_DIR, 'cc_sessions/hooks', file),\n   163→        path.join(PROJECT_ROOT, '.claude/hooks', file)\n   164→      );\n   165→      await fs.chmod(path.join(PROJECT_ROOT, '.claude/hooks', file), 0o755);\n   166→    }\n   167→  }\n   168→  \n   169→  console.log(color('Installing protocols...', colors.cyan));\n   170→  const protocolFiles = await fs.readdir(path.join(SCRIPT_DIR, 'cc_sessions/protocols'));\n   171→  for (const file of protocolFiles) {\n   172→    if (file.endsWith('.md')) {\n   173→      await fs.copyFile(\n   174→        path.join(SCRIPT_DIR, 'cc_sessions/protocols', file),\n   175→        path.join(PROJECT_ROOT, 'sessions/protocols', file)\n   176→      );\n   177→    }\n   178→  }\n   179→  \n   180→  console.log(color('Installing agent definitions...', colors.cyan));\n   181→  const agentFiles = await fs.readdir(path.join(SCRIPT_DIR, 'cc_sessions/agents'));\n   182→  for (const file of agentFiles) {\n   183→    if (file.endsWith('.md')) {\n   184→      await fs.copyFile(\n   185→        path.join(SCRIPT_DIR, 'cc_sessions/agents', file),\n   186→        path.join(PROJECT_ROOT, '.claude/agents', file)\n   187→      );\n   188→    }\n   189→  }\n   190→  \n   191→  console.log(color('Installing templates...', colors.cyan));\n   192→  await fs.copyFile(\n   193→    path.join(SCRIPT_DIR, 'cc_sessions/templates/TEMPLATE.md'),\n   194→    path.join(PROJECT_ROOT, 'sessions/tasks/TEMPLATE.md')\n   195→  );\n   196→  \n   197→  console.log(color('Installing commands...', colors.cyan));\n   198→  const commandFiles = await fs.readdir(path.join(SCRIPT_DIR, 'cc_sessions/commands'));\n   199→  for (const file of commandFiles) {\n   200→    if (file.endsWith('.md')) {\n   201→      await fs.copyFile(\n   202→        path.join(SCRIPT_DIR, 'cc_sessions/commands', file),\n   203→        path.join(PROJECT_ROOT, '.claude/commands', file)\n   204→      );\n   205→    }\n   206→  }\n   207→  \n   208→  // Copy knowledge files if they exist\n   209→  const knowledgePath = path.join(SCRIPT_DIR, 'cc_sessions/knowledge/claude-code');\n   210→  try {\n   211→    await fs.access(knowledgePath);\n   212→    console.log(color('Installing Claude Code knowledge base...', colors.cyan));\n   213→    await copyDir(knowledgePath, path.join(PROJECT_ROOT, 'sessions/knowledge/claude-code'));\n   214→  } catch {\n   215→    // Knowledge files don't exist, skip\n   216→  }\n   217→}\n   218→\n   219→// Recursive directory copy\n   220→async function copyDir(src, dest) {\n   221→  await fs.mkdir(dest, { recursive: true });\n   222→  const entries = await fs.readdir(src, { withFileTypes: true });\n   223→  \n   224→  for (const entry of entries) {\n   225→    const srcPath = path.join(src, entry.name);\n   226→    const destPath = path.join(dest, entry.name);\n   227→    \n   228→    if (entry.isDirectory()) {\n   229→      await copyDir(srcPath, destPath);\n   230→    } else {\n   231→      await fs.copyFile(srcPath, destPath);\n   232→    }\n   233→  }\n   234→}\n   235→\n   236→// Install daic command\n   237→async function installDaicCommand() {\n   238→  console.log(color('Installing daic command...', colors.cyan));\n   239→  \n   240→  const daicSource = path.join(SCRIPT_DIR, 'cc_sessions/scripts/daic');\n   241→  const daicDest = '/usr/local/bin/daic';\n   242→  \n   243→  try {\n   244→    await fs.copyFile(daicSource, daicDest);\n   245→    await fs.chmod(daicDest, 0o755);\n   246→  } catch (error) {\n   247→    if (error.code === 'EACCES') {\n   248→      console.log(color('⚠️  Cannot write to /usr/local/bin. Trying with sudo...', colors.yellow));\n   249→      try {\n   250→        execSync(`sudo cp ${daicSource} ${daicDest}`, { stdio: 'inherit' });\n   251→        execSync(`sudo chmod +x ${daicDest}`, { stdio: 'inherit' });\n   252→      } catch {\n   253→        console.log(color('⚠️  Could not install daic command globally. You can run it locally from .claude/scripts/', colors.yellow));\n   254→      }\n   255→    }\n   256→  }\n   257→}\n   258→\n   259→// Interactive menu with keyboard navigation\n   260→async function interactiveMenu(items, options = {}) {\n   261→  const {\n   262→    title = 'Select an option',\n   263→    multiSelect = false,\n   264→    selectedItems = new Set(),\n   265→    formatItem = (item, selected) => item\n   266→  } = options;\n   267→  \n   268→  let currentIndex = 0;\n   269→  let selected = new Set(selectedItems);\n   270→  let done = false;\n   271→  \n   272→  // Hide cursor\n   273→  process.stdout.write('\\x1B[?25l');\n   274→  \n   275→  const renderMenu = () => {\n   276→    // Clear previous menu\n   277→    console.clear();\n   278→    \n   279→    // Render title\n   280→    if (title) {\n   281→      console.log(title);\n   282→    }\n   283→    \n   284→    // Render items\n   285→    items.forEach((item, index) => {\n   286→      const isSelected = selected.has(item);\n   287→      const isCurrent = index === currentIndex;\n   288→      \n   289→      let prefix = '  ';\n   290→      if (isCurrent) {\n   291→        prefix = color('▶ ', colors.cyan);\n   292→      }\n   293→      \n   294→      console.log(prefix + formatItem(item, isSelected, isCurrent));\n   295→    });\n   296→  };\n   297→  \n   298→  return new Promise((resolve) => {\n   299→    renderMenu();\n   300→    \n   301→    // Set raw mode for key input\n   302→    readline.emitKeypressEvents(process.stdin);\n   303→    if (process.stdin.setRawMode) {\n   304→      process.stdin.setRawMode(true);\n   305→    }\n   306→    process.stdin.resume();\n   307→    \n   308→    const keyHandler = (str, key) => {\n   309→      if (key) {\n   310→        if (key.name === 'up') {\n   311→          currentIndex = (currentIndex - 1 + items.length) % items.length;\n   312→          renderMenu();\n   313→        } else if (key.name === 'down') {\n   314→          currentIndex = (currentIndex + 1) % items.length;\n   315→          renderMenu();\n   316→        } else if (key.name === 'space' && multiSelect) {\n   317→          const item = items[currentIndex];\n   318→          if (selected.has(item)) {\n   319→            selected.delete(item);\n   320→          } else {\n   321→            selected.add(item);\n   322→          }\n   323→          renderMenu();\n   324→        } else if (key.name === 'return') {\n   325→          done = true;\n   326→          // Restore terminal\n   327→          if (process.stdin.setRawMode) {\n   328→            process.stdin.setRawMode(false);\n   329→          }\n   330→          process.stdin.removeListener('keypress', keyHandler);\n   331→          process.stdout.write('\\x1B[?25h'); // Show cursor\n   332→          console.clear();\n   333→          \n   334→          // Resume stdin for subsequent prompts (don't pause!)\n   335→          process.stdin.resume();\n   336→          \n   337→          if (multiSelect) {\n   338→            resolve(selected);\n   339→          } else {\n   340→            resolve(items[currentIndex]);\n   341→          }\n   342→        } else if (key.ctrl && key.name === 'c') {\n   343→          // Handle Ctrl+C\n   344→          if (process.stdin.setRawMode) {\n   345→            process.stdin.setRawMode(false);\n   346→          }\n   347→          process.stdin.pause();\n   348→          process.stdout.write('\\x1B[?25h'); // Show cursor\n   349→          process.exit(0);\n   350→        }\n   351→      }\n   352→    };\n   353→    \n   354→    process.stdin.on('keypress', keyHandler);\n   355→  });\n   356→}\n   357→\n   358→// Tool blocking menu\n   359→async function configureToolBlocking() {\n   360→  const allTools = [\n   361→    { name: 'Edit', description: 'Edit existing files', defaultBlocked: true },\n   362→    { name: 'Write', description: 'Create new files', defaultBlocked: true },\n   363→    { name: 'MultiEdit', description: 'Multiple edits in one operation', defaultBlocked: true },\n   364→    { name: 'NotebookEdit', description: 'Edit Jupyter notebooks', defaultBlocked: true },\n   365→    { name: 'Bash', description: 'Run shell commands', defaultBlocked: false },\n   366→    { name: 'Read', description: 'Read file contents', defaultBlocked: false },\n   367→    { name: 'Grep', description: 'Search file contents', defaultBlocked: false },\n   368→    { name: 'Glob', description: 'Find files by pattern', defaultBlocked: false },\n   369→    { name: 'LS', description: 'List directory contents', defaultBlocked: false },\n   370→    { name: 'WebSearch', description: 'Search the web', defaultBlocked: false },\n   371→    { name: 'WebFetch', description: 'Fetch web content', defaultBlocked: false },\n   372→    { name: 'Task', description: 'Launch specialized agents', defaultBlocked: false }\n   373→  ];\n   374→  \n   375→  // Initialize blocked tools\n   376→  const initialBlocked = new Set(config.blocked_tools.map(name => \n   377→    allTools.find(t => t.name === name)\n   378→  ).filter(Boolean));\n   379→  \n   380→  const title = `${color('╭───────────────────────────────────────────────────────────────╮', colors.cyan)}\n   381→${color('│              Tool Blocking Configuration                      │', colors.cyan)}\n   382→${color('├───────────────────────────────────────────────────────────────┤', colors.cyan)}\n   383→${color('│   ↑/↓: Navigate   SPACE: Toggle   ENTER: Save & Continue      │', colors.dim)}\n   384→${color('│     Tools marked with 🔒 are blocked in discussion mode       │', colors.dim)}\n   385→${color('╰───────────────────────────────────────────────────────────────╯', colors.cyan)}\n   386→`;\n   387→  \n   388→  const formatItem = (tool, isBlocked, isCurrent) => {\n   389→    const icon = isBlocked ? icons.lock : icons.unlock;\n   390→    const status = isBlocked ? color('[BLOCKED]', colors.red) : color('[ALLOWED]', colors.green);\n   391→    const toolColor = isCurrent ? colors.bright : (isBlocked ? colors.yellow : colors.white);\n   392→    \n   393→    return `${icon} ${color(tool.name.padEnd(15), toolColor)} - ${tool.description.padEnd(30)} ${status}`;\n   394→  };\n   395→  \n   396→  const selectedTools = await interactiveMenu(allTools, {\n   397→    title,\n   398→    multiSelect: true,\n   399→    selectedItems: initialBlocked,\n   400→    formatItem\n   401→  });\n   402→  \n   403→  config.blocked_tools = Array.from(selectedTools).map(t => t.name);\n   404→  console.log(color(`\\n  ${icons.check} Tool blocking configuration saved`, colors.green));\n   405→}\n   406→\n   407→// Interactive configuration\n   408→async function configure() {\n   409→  console.log();\n   410→  console.log(color('╔═══════════════════════════════════════════════════════════════╗', colors.bright + colors.cyan));\n   411→  console.log(color('║                    CONFIGURATION SETUP                        ║', colors.bright + colors.cyan));\n   412→  console.log(color('╚═══════════════════════════════════════════════════════════════╝', colors.bright + colors.cyan));\n   413→  console.log();\n   414→  \n   415→  let statuslineInstalled = false;\n   416→  \n   417→  // Developer name section\n   418→  console.log(color(`\\n${icons.star} DEVELOPER IDENTITY`, colors.bright + colors.magenta));\n   419→  console.log(color('─'.repeat(60), colors.dim));\n   420→  console.log(color('  Claude will use this name when addressing you in sessions', colors.dim));\n   421→  console.log();\n   422→  \n   423→  const name = await question(color('  Your name: ', colors.cyan));\n   424→  if (name) {\n   425→    config.developer_name = name;\n   426→    console.log(color(`  ${icons.check} Hello, ${name}!`, colors.green));\n   427→  }\n   428→  \n   429→  // Statusline installation section\n   430→  console.log(color(`\\n\\n${icons.star} STATUSLINE INSTALLATION`, colors.bright + colors.magenta));\n   431→  console.log(color('─'.repeat(60), colors.dim));\n   432→  console.log(color('  Real-time status display in Claude Code showing:', colors.white));\n   433→  console.log(color(`    ${icons.bullet} Current task and DAIC mode`, colors.cyan));\n   434→  console.log(color(`    ${icons.bullet} Token usage with visual progress bar`, colors.cyan));\n   435→  console.log(color(`    ${icons.bullet} Modified file counts`, colors.cyan));\n   436→  console.log(color(`    ${icons.bullet} Open task count`, colors.cyan));\n   437→  console.log();\n   438→  \n   439→  const installStatusline = await question(color('  Install statusline? (y/n): ', colors.cyan));\n   440→  \n   441→  if (installStatusline.toLowerCase() === 'y') {\n   442→    const statuslineSource = path.join(SCRIPT_DIR, 'cc_sessions/scripts/statusline-script.sh');\n   443→    try {\n   444→      await fs.access(statuslineSource);\n   445→      console.log(color('  Installing statusline script...', colors.dim));\n   446→      await fs.copyFile(statuslineSource, path.join(PROJECT_ROOT, '.claude/statusline-script.sh'));\n   447→      await fs.chmod(path.join(PROJECT_ROOT, '.claude/statusline-script.sh'), 0o755);\n   448→      statuslineInstalled = true;\n   449→      console.log(color(`  ${icons.check} Statusline installed successfully`, colors.green));\n   450→    } catch {\n   451→      console.log(color(`  ${icons.warning} Statusline script not found in package`, colors.yellow));\n   452→    }\n   453→  }\n   454→  \n   455→  // DAIC trigger phrases section\n   456→  console.log(color(`\\n\\n${icons.star} DAIC WORKFLOW CONFIGURATION`, colors.bright + colors.magenta));\n   457→  console.log(color('─'.repeat(60), colors.dim));\n   458→  console.log(color('  The DAIC system enforces discussion before implementation.', colors.white));\n   459→  console.log(color('  Trigger phrases tell Claude when you\\'re ready to proceed.', colors.white));\n   460→  console.log();\n   461→  console.log(color('  Default triggers:', colors.cyan));\n   462→  config.trigger_phrases.forEach(phrase => {\n   463→    console.log(color(`    ${icons.arrow} \"${phrase}\"`, colors.green));\n   464→  });\n   465→  console.log();\n   466→  console.log(color('  Hint: Common additions: \"implement it\", \"do it\", \"proceed\"', colors.dim));\n   467→  console.log();\n   468→  \n   469→  // Allow adding multiple custom trigger phrases\n   470→  let addingTriggers = true;\n   471→  while (addingTriggers) {\n   472→    const customTrigger = await question(color('  Add custom trigger phrase (Enter to skip): ', colors.cyan));\n   473→    if (customTrigger) {\n   474→      config.trigger_phrases.push(customTrigger);\n   475→      console.log(color(`  ${icons.check} Added: \"${customTrigger}\"`, colors.green));\n   476→    } else {\n   477→      addingTriggers = false;\n   478→    }\n   479→  }\n   480→  \n   481→  // API Mode configuration\n   482→  console.log(color(`\\n\\n${icons.star} THINKING BUDGET CONFIGURATION`, colors.bright + colors.magenta));\n   483→  console.log(color('─'.repeat(60), colors.dim));\n   484→  console.log(color('  Token usage is not much of a concern with Claude Code Max', colors.white));\n   485→  console.log(color('  plans, especially the $200 tier. But API users are often', colors.white));\n   486→  console.log(color('  budget-conscious and want manual control.', colors.white));\n   487→  console.log();\n   488→  console.log(color('  Sessions was built to preserve tokens across context windows', colors.cyan));\n   489→  console.log(color('  but uses saved tokens to enable \\'ultrathink\\' - Claude\\'s', colors.cyan));\n   490→  console.log(color('  maximum thinking budget - on every interaction for best results.', colors.cyan));\n   491→  console.log();\n   492→  console.log(color('  • Max users (recommended): Automatic ultrathink every message', colors.dim));\n   493→  console.log(color('  • API users: Manual control with [[ ultrathink ]] when needed', colors.dim));\n   494→  console.log();\n   495→  console.log(color('  You can toggle this anytime with: /api-mode', colors.dim));\n   496→  console.log();\n   497→  \n   498→  const enableUltrathink = await question(color('  Enable automatic ultrathink for best performance? (y/n): ', colors.cyan));\n   499→  if (enableUltrathink.toLowerCase() === 'y' || enableUltrathink.toLowerCase() === 'yes') {\n   500→    config.api_mode = false;\n   501→    console.log(color(`  ${icons.check} Max mode - ultrathink enabled for best performance`, colors.green));\n   502→  } else {\n   503→    config.api_mode = true;\n   504→    console.log(color(`  ${icons.check} API mode - manual ultrathink control (use [[ ultrathink ]])`, colors.green));\n   505→  }\n   506→  \n   507→  // Advanced configuration\n   508→  console.log(color(`\\n\\n${icons.star} ADVANCED OPTIONS`, colors.bright + colors.magenta));\n   509→  console.log(color('─'.repeat(60), colors.dim));\n   510→  console.log(color('  Configure tool blocking, task prefixes, and more', colors.white));\n   511→  console.log();\n   512→  \n   513→  const advanced = await question(color('  Configure advanced options? (y/n): ', colors.cyan));\n   514→  \n   515→  if (advanced.toLowerCase() === 'y') {\n   516→    await configureToolBlocking();\n   517→    \n   518→    // Task prefix configuration\n   519→    console.log(color(`\\n\\n${icons.star} TASK PREFIX CONFIGURATION`, colors.bright + colors.magenta));\n   520→    console.log(color('─'.repeat(60), colors.dim));\n   521→    console.log(color('  Task prefixes organize work by priority and type', colors.white));\n   522→    console.log();\n   523→    console.log(color('  Current prefixes:', colors.cyan));\n   524→    console.log(color(`    ${icons.arrow} h- (high priority)`, colors.white));\n   525→    console.log(color(`    ${icons.arrow} m- (medium priority)`, colors.white));\n   526→    console.log(color(`    ${icons.arrow} l- (low priority)`, colors.white));\n   527→    console.log(color(`    ${icons.arrow} ?- (investigate/research)`, colors.white));\n   528→    console.log();\n   529→    \n   530→    const customizePrefixes = await question(color('  Customize task prefixes? (y/n): ', colors.cyan));\n   531→    if (customizePrefixes.toLowerCase() === 'y') {\n   532→      const high = await question(color('  High priority prefix [h-]: ', colors.cyan)) || 'h-';\n   533→      const med = await question(color('  Medium priority prefix [m-]: ', colors.cyan)) || 'm-';\n   534→      const low = await question(color('  Low priority prefix [l-]: ', colors.cyan)) || 'l-';\n   535→      const inv = await question(color('  Investigate prefix [?-]: ', colors.cyan)) || '?-';\n   536→      \n   537→      config.task_prefixes = {\n   538→        priority: [high, med, low, inv]\n   539→      };\n   540→      \n   541→      console.log(color(`  ${icons.check} Task prefixes updated`, colors.green));\n   542→    }\n   543→  }\n   544→  \n   545→  return { statuslineInstalled };\n   546→}\n   547→\n   548→// Save configuration\n   549→async function saveConfig(installStatusline = false) {\n   550→  console.log(color('Creating configuration...', colors.cyan));\n   551→  \n   552→  await fs.writeFile(\n   553→    path.join(PROJECT_ROOT, 'sessions/sessions-config.json'),\n   554→    JSON.stringify(config, null, 2)\n   555→  );\n   556→  \n   557→  // Create or update .claude/settings.json with hooks configuration\n   558→  const settingsPath = path.join(PROJECT_ROOT, '.claude/settings.json');\n   559→  let settings = {};\n   560→  \n   561→  // Check if settings.json already exists\n   562→  try {\n   563→    const existingSettings = await fs.readFile(settingsPath, 'utf-8');\n   564→    settings = JSON.parse(existingSettings);\n   565→    console.log(color('Found existing settings.json, merging sessions hooks...', colors.cyan));\n   566→  } catch {\n   567→    console.log(color('Creating new settings.json with sessions hooks...', colors.cyan));\n   568→  }\n   569→  \n   570→  // Define the sessions hooks\n   571→  const sessionsHooks = {\n   572→    UserPromptSubmit: [\n   573→      {\n   574→        hooks: [\n   575→          {\n   576→            type: \"command\",\n   577→            command: \"$CLAUDE_PROJECT_DIR/.claude/hooks/user-messages.py\"\n   578→          }\n   579→        ]\n   580→      }\n   581→    ],\n   582→    PreToolUse: [\n   583→      {\n   584→        matcher: \"Write|Edit|MultiEdit|Task|Bash\",\n   585→        hooks: [\n   586→          {\n   587→            type: \"command\",\n   588→            command: \"$CLAUDE_PROJECT_DIR/.claude/hooks/sessions-enforce.py\"\n   589→          }\n   590→        ]\n   591→      },\n   592→      {\n   593→        matcher: \"Task\",\n   594→        hooks: [\n   595→          {\n   596→            type: \"command\",\n   597→            command: \"$CLAUDE_PROJECT_DIR/.claude/hooks/task-transcript-link.py\"\n   598→          }\n   599→        ]\n   600→      }\n   601→    ],\n   602→    PostToolUse: [\n   603→      {\n   604→        hooks: [\n   605→          {\n   606→            type: \"command\",\n   607→            command: \"$CLAUDE_PROJECT_DIR/.claude/hooks/post-tool-use.py\"\n   608→          }\n   609→        ]\n   610→      }\n   611→    ],\n   612→    SessionStart: [\n   613→      {\n   614→        matcher: \"startup|clear\",\n   615→        hooks: [\n   616→          {\n   617→            type: \"command\",\n   618→            command: \"$CLAUDE_PROJECT_DIR/.claude/hooks/session-start.py\"\n   619→          }\n   620→        ]\n   621→      }\n   622→    ]\n   623→  };\n   624→  \n   625→  // Merge hooks (sessions hooks take precedence)\n   626→  if (!settings.hooks) {\n   627→    settings.hooks = {};\n   628→  }\n   629→  \n   630→  // Merge each hook type\n   631→  for (const [hookType, hookConfig] of Object.entries(sessionsHooks)) {\n   632→    if (!settings.hooks[hookType]) {\n   633→      settings.hooks[hookType] = hookConfig;\n   634→    } else {\n   635→      // Append sessions hooks to existing ones\n   636→      settings.hooks[hookType] = [...settings.hooks[hookType], ...hookConfig];\n   637→    }\n   638→  }\n   639→  \n   640→  // Add statusline if requested\n   641→  if (installStatusline) {\n   642→    settings.statusLine = {\n   643→      type: \"command\",\n   644→      command: \"$CLAUDE_PROJECT_DIR/.claude/statusline-script.sh\",\n   645→      padding: 0\n   646→    };\n   647→  }\n   648→  \n   649→  // Save the updated settings\n   650→  await fs.writeFile(settingsPath, JSON.stringify(settings, null, 2));\n   651→  console.log(color('✅ Sessions hooks configured in settings.json', colors.green));\n   652→  \n   653→  // Initialize DAIC state\n   654→  await fs.writeFile(\n   655→    path.join(PROJECT_ROOT, '.claude/state/daic-mode.json'),\n   656→    JSON.stringify({ mode: \"discussion\" }, null, 2)\n   657→  );\n   658→  \n   659→  // Create initial task state\n   660→  const currentDate = new Date().toISOString().split('T')[0];\n   661→  await fs.writeFile(\n   662→    path.join(PROJECT_ROOT, '.claude/state/current_task.json'),\n   663→    JSON.stringify({\n   664→      task: null,\n   665→      branch: null,\n   666→      services: [],\n   667→      updated: currentDate\n   668→    }, null, 2)\n   669→  );\n   670→}\n   671→\n   672→// CLAUDE.md integration\n   673→async function setupClaudeMd() {\n   674→  console.log();\n   675→  console.log(color('═══════════════════════════════════════════', colors.bright));\n   676→  console.log(color('         CLAUDE.md Integration', colors.bright));\n   677→  console.log(color('═══════════════════════════════════════════', colors.bright));\n   678→  console.log();\n   679→  \n   680→  // Check for existing CLAUDE.md\n   681→  try {\n   682→    await fs.access(path.join(PROJECT_ROOT, 'CLAUDE.md'));\n   683→    \n   684→    // File exists, preserve it and add sessions as separate file\n   685→    console.log(color('CLAUDE.md already exists, preserving your project-specific rules...', colors.cyan));\n   686→    \n   687→    // Copy CLAUDE.sessions.md as separate file\n   688→    await fs.copyFile(\n   689→      path.join(SCRIPT_DIR, 'cc_sessions/templates/CLAUDE.sessions.md'),\n   690→      path.join(PROJECT_ROOT, 'CLAUDE.sessions.md')\n   691→    );\n   692→    \n   693→    // Check if it already includes sessions\n   694→    const content = await fs.readFile(path.join(PROJECT_ROOT, 'CLAUDE.md'), 'utf-8');\n   695→    if (!content.includes('@CLAUDE.sessions.md')) {\n   696→      console.log(color('Adding sessions include to existing CLAUDE.md...', colors.cyan));\n   697→      \n   698→      const addition = '\\n## Sessions System Behaviors\\n\\n@CLAUDE.sessions.md\\n';\n   699→      await fs.appendFile(path.join(PROJECT_ROOT, 'CLAUDE.md'), addition);\n   700→      \n   701→      console.log(color('✅ Added @CLAUDE.sessions.md include to your CLAUDE.md', colors.green));\n   702→    } else {\n   703→      console.log(color('✅ CLAUDE.md already includes sessions behaviors', colors.green));\n   704→    }\n   705→  } catch {\n   706→    // File doesn't exist, use sessions as CLAUDE.md\n   707→    console.log(color('No existing CLAUDE.md found, installing sessions as your CLAUDE.md...', colors.cyan));\n   708→    await fs.copyFile(\n   709→      path.join(SCRIPT_DIR, 'cc_sessions/templates/CLAUDE.sessions.md'),\n   710→      path.join(PROJECT_ROOT, 'CLAUDE.md')\n   711→    );\n   712→    console.log(color('✅ CLAUDE.md created with complete sessions behaviors', colors.green));\n   713→  }\n   714→}\n   715→\n   716→// Main installation function\n   717→async function install() {\n   718→  console.log(color('╔════════════════════════════════════════════╗', colors.bright));\n   719→  console.log(color('║            cc-sessions Installer           ║', colors.bright));\n   720→  console.log(color('╚════════════════════════════════════════════╝', colors.bright));\n   721→  console.log();\n   722→  \n   723→  // Detect correct project directory\n   724→  await detectProjectDirectory();\n   725→  \n   726→  // Check CLAUDE_PROJECT_DIR\n   727→  if (!process.env.CLAUDE_PROJECT_DIR) {\n   728→    console.log(color(`⚠️  CLAUDE_PROJECT_DIR not set. Setting it to ${PROJECT_ROOT}`, colors.yellow));\n   729→    console.log('   To make this permanent, add to your shell profile:');\n   730→    console.log(`   export CLAUDE_PROJECT_DIR=\"${PROJECT_ROOT}\"`);\n   731→    console.log();\n   732→  }\n   733→  \n   734→  try {\n   735→    await checkDependencies();\n   736→    await createDirectories();\n   737→    await installPythonDeps();\n   738→    await copyFiles();\n   739→    await installDaicCommand();\n   740→    const { statuslineInstalled } = await configure();\n   741→    await saveConfig(statuslineInstalled);\n   742→    await setupClaudeMd();\n   743→    \n   744→    // Success message\n   745→    console.log();\n   746→    console.log();\n   747→    console.log(color('╔═══════════════════════════════════════════════════════════════╗', colors.bright + colors.green));\n   748→    console.log(color('║                 🎉 INSTALLATION COMPLETE! 🎉                  ║', colors.bright + colors.green));\n   749→    console.log(color('╚═══════════════════════════════════════════════════════════════╝', colors.bright + colors.green));\n   750→    console.log();\n   751→    \n   752→    console.log(color('  Installation Summary:', colors.bright + colors.cyan));\n   753→    console.log(color('  ─────────────────────', colors.dim));\n   754→    console.log(color(`  ${icons.check} Directory structure created`, colors.green));\n   755→    console.log(color(`  ${icons.check} Hooks installed and configured`, colors.green));\n   756→    console.log(color(`  ${icons.check} Protocols and agents deployed`, colors.green));\n   757→    console.log(color(`  ${icons.check} daic command available globally`, colors.green));\n   758→    console.log(color(`  ${icons.check} Configuration saved`, colors.green));\n   759→    console.log(color(`  ${icons.check} DAIC state initialized (Discussion mode)`, colors.green));\n   760→    \n   761→    if (statuslineInstalled) {\n   762→      console.log(color(`  ${icons.check} Statusline configured`, colors.green));\n   763→    }\n   764→    \n   765→    console.log();\n   766→    \n   767→    // Test daic command\n   768→    if (commandExists('daic')) {\n   769→      console.log(color(`  ${icons.check} daic command verified and working`, colors.green));\n   770→    } else {\n   771→      console.log(color(`  ${icons.warning} daic command not in PATH`, colors.yellow));\n   772→      console.log(color('       Add /usr/local/bin to your PATH', colors.dim));\n   773→    }\n   774→    \n   775→    console.log();\n   776→    console.log(color(`  ${icons.star} NEXT STEPS`, colors.bright + colors.magenta));\n   777→    console.log(color('  ─────────────', colors.dim));\n   778→    console.log();\n   779→    console.log(color('  1. Restart Claude Code to activate the sessions hooks', colors.white));\n   780→    console.log(color('     ' + icons.arrow + ' Close and reopen Claude Code', colors.dim));\n   781→    console.log();\n   782→    console.log(color('  2. Create your first task:', colors.white));\n   783→    console.log(color('     ' + icons.arrow + ' Tell Claude: \"Create a new task\"', colors.cyan));\n   784→    console.log(color('     ' + icons.arrow + ' Or: \"Create a task for implementing feature X\"', colors.cyan));\n   785→    console.log();\n   786→    console.log(color('  3. Start working with the DAIC workflow:', colors.white));\n   787→    console.log(color('     ' + icons.arrow + ' Discuss approach first', colors.dim));\n   788→    console.log(color('     ' + icons.arrow + ' Say \"make it so\" to implement', colors.dim));\n   789→    console.log(color('     ' + icons.arrow + ' Run \"daic\" to return to discussion', colors.dim));\n   790→    console.log();\n   791→    console.log(color('  ──────────────────────────────────────────────────────', colors.dim));\n   792→    console.log();\n   793→    console.log(color(`  Welcome aboard, ${config.developer_name}! 🚀`, colors.bright + colors.cyan));\n   794→    \n   795→  } catch (error) {\n   796→    console.error(color(`❌ Installation failed: ${error.message}`, colors.red));\n   797→    process.exit(1);\n   798→  } finally {\n   799→    rl.close();\n   800→  }\n   801→}\n   802→\n   803→// Run installation\n   804→if (require.main === module) {\n   805→  install().catch(error => {\n   806→    console.error(color(`❌ Fatal error: ${error}`, colors.red));\n   807→    process.exit(1);\n   808→  });\n   809→}\n   810→\n   811→module.exports = { install };\n   812→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  }
]